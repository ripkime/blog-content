---
title: "FlashTix: High-Concurrency Booking Engine"
description: "Designing a race-condition-free ticketing system capable of handling 10,000 requests per second during peak sales without overselling."
date: "Jan 28, 2026"
readTime: "12 min"
author: "Rifki"
tags: ["Backend", "System Design", "Go"]
youtubeId: "cVMX7_m75-s"
repoLink: "https://github.com/ripkime/flashtix"
demoLink: "https://flashtix.ripki.me"
---

<script>
  import { Terminal, Database, Cpu, Layers, Server, Globe } from '$lib/icons';
</script>

## The Challenge

Building a ticketing platform is deceptively simple until you hit scale. The core problem isn't just serving content, but managing **State Consistency** under extreme concurrency.

When 500 users try to buy the *exact same seat* (Seat A-12) at the same millisecond, a standard database update will fail or, worse, allow **overselling** (selling 1 seat to 10 people).

My goals for this project were:
1.  **Zero Overselling:** ACID compliance is non-negotiable.
2.  **High Throughput:** Handle sudden spikes (e.g., Coldplay ticket sales).
3.  **Fairness:** First come, first served using a queue system.

---

## Technology Stack

I chose Golang for its raw performance and excellent concurrency primitives (Goroutines), paired with Redis for rapid state management.

<div class="grid grid-cols-1 gap-6 md:grid-cols-2 not-prose my-8">
  <div class="rounded-xl border border-white/10 bg-[#0a0a0c] p-6 transition-colors hover:border-primary/30">
    <div class="mb-4 flex items-center gap-3">
      <div class="flex size-10 items-center justify-center rounded-lg bg-cyan-500/10 text-cyan-400">
        <Server class="size-6" />
      </div>
      <h3 class="text-lg font-bold text-white m-0">Core Backend</h3>
    </div>
    <div class="flex flex-wrap gap-2">
      <span class="rounded-md border border-white/5 bg-white/5 px-2.5 py-1 font-mono text-xs text-slate-300">Go (Golang)</span>
      <span class="rounded-md border border-white/5 bg-white/5 px-2.5 py-1 font-mono text-xs text-slate-300">Fiber (Web Framework)</span>
      <span class="rounded-md border border-white/5 bg-white/5 px-2.5 py-1 font-mono text-xs text-slate-300">gRPC</span>
    </div>
  </div>

  <div class="rounded-xl border border-white/10 bg-[#0a0a0c] p-6 transition-colors hover:border-primary/30">
    <div class="mb-4 flex items-center gap-3">
      <div class="flex size-10 items-center justify-center rounded-lg bg-green-500/10 text-green-400">
        <Database class="size-6" />
      </div>
      <h3 class="text-lg font-bold text-white m-0">Data & Queues</h3>
    </div>
    <div class="flex flex-wrap gap-2">
      <span class="rounded-md border border-white/5 bg-white/5 px-2.5 py-1 font-mono text-xs text-slate-300">PostgreSQL</span>
      <span class="rounded-md border border-white/5 bg-white/5 px-2.5 py-1 font-mono text-xs text-slate-300">Redis (Pub/Sub)</span>
      <span class="rounded-md border border-white/5 bg-white/5 px-2.5 py-1 font-mono text-xs text-slate-300">RabbitMQ</span>
    </div>
  </div>
</div>

---

## System Architecture

To handle the load, I decoupled the **Booking Request** from the **Order Processing**. When a user clicks "Buy", they aren't writing to the DB directly. Instead, they enter a Waiting Room (Queue).

<div class="group relative overflow-hidden rounded-xl border border-white/10 p-8 shadow-2xl bg-[#0a0a0c] not-prose my-8">
    <div class="pointer-events-none absolute top-1/2 left-1/2 h-96 w-96 -translate-x-1/2 -translate-y-1/2 rounded-full bg-indigo-500/10 blur-[100px]"></div>
    <div class="relative z-10 flex flex-col items-center">
        <div class="flex flex-col md:flex-row items-center justify-center gap-6 md:gap-8 w-full">
            
            <div class="flex flex-col items-center gap-2">
                <div class="flex size-14 items-center justify-center rounded-xl border border-white/20 bg-slate-800 shadow-lg">
                    <Globe class="size-6 text-white" />
                </div>
                <span class="text-[10px] uppercase tracking-widest text-slate-500">User</span>
            </div>

            <div class="h-8 w-0.5 md:h-0.5 md:w-12 bg-slate-700 relative"></div>

            <div class="flex flex-col items-center gap-2">
                <div class="flex size-14 items-center justify-center rounded-xl border border-primary/50 bg-primary/10 shadow-[0_0_15px_rgba(59,130,246,0.3)]">
                    <Layers class="size-6 text-primary" />
                </div>
                <span class="text-[10px] uppercase tracking-widest text-primary">Gateway</span>
            </div>

            <div class="h-8 w-0.5 md:h-0.5 md:w-12 bg-slate-700 relative"></div>

            <div class="flex flex-col items-center gap-2">
                <div class="flex size-14 items-center justify-center rounded-xl border border-orange-500/30 bg-orange-500/10">
                    <Cpu class="size-6 text-orange-400" />
                </div>
                <span class="text-[10px] uppercase tracking-widest text-orange-400">RabbitMQ</span>
            </div>

             <div class="h-8 w-0.5 md:h-0.5 md:w-12 bg-slate-700 relative"></div>

            <div class="flex flex-col items-center gap-2">
                <div class="flex size-14 items-center justify-center rounded-xl border border-green-500/30 bg-green-500/10">
                    <Database class="size-6 text-green-400" />
                </div>
                <span class="text-[10px] uppercase tracking-widest text-green-400">Worker</span>
            </div>

        </div>
    </div>
</div>

---

## Database Design

Handling booking states requires a precise schema. I used **Eraser.io** to map out the relationship between `Events`, `Seats`, and `Transactions`.

The key here is the `version` column in the **Seat** table, which acts as an **Optimistic Locking** mechanism.

<div class="rounded-xl border border-white/10 bg-[#0d0d10] p-4 my-8 not-prose">
    <img 
        src="https://images.unsplash.com/photo-1558494949-ef526b0042a0?auto=format&fit=crop&q=80&w=2000" 
        alt="Database Schema ERD" 
        class="w-full rounded-lg opacity-80 hover:opacity-100 transition-opacity"
    />
    <p class="text-center text-xs text-slate-500 mt-4 italic">
        Figure 2.1: Entity Relationship Diagram showing Optimistic Locking fields
    </p>
</div>

---

## Implementation Details

### Preventing Race Conditions
To ensure a seat is never sold twice, I utilized **PostgreSQL Transactions** with `SELECT FOR UPDATE SKIP LOCKED`. This allows high throughput by skipping rows that are currently being processed by other transactions, rather than waiting (blocking).

```go title="internal/repository/booking.go"
func (r *repo) BookSeat(ctx context.Context, seatID uuid.UUID, userID uuid.UUID) error {
    tx, err := r.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // 1. Lock the seat row specifically
    // "SKIP LOCKED" prevents thundering herd problem
    var currentStatus string
    query := `SELECT status FROM seats WHERE id = $1 FOR UPDATE SKIP LOCKED`
    
    err = tx.QueryRowContext(ctx, query, seatID).Scan(&currentStatus)
    if err != nil {
        return fmt.Errorf("seat unavailable or locked: %w", err)
    }

    if currentStatus != "AVAILABLE" {
        return fmt.Errorf("seat already taken")
    }

    // 2. Update status to BOOKED
    _, err = tx.ExecContext(ctx, `UPDATE seats SET status = 'BOOKED', user_id = $1 WHERE id = $2`, userID, seatID)
    if err != nil {
        return err
    }

    return tx.Commit()
}

---

## The Waiting Room (Rate Limiting)
### Before hitting the database, users are put into a Redis Sorted Set. A background worker allows only N users per second to proceed to the checkout page.

```go title="internal/repository/booking.go"
func ProcessQueue() {
    for {
        // Pop top 50 users from the waiting list
        users, _ := redisClient.ZPopMin(ctx, "waiting_room", 50).Result()
        
        if len(users) == 0 {
            time.Sleep(1 * time.Second)
            continue
        }

        // Grant them a temporary access token (JWT)
        for _, user := range users {
            token := generateCheckoutToken(user.Member)
            notifyUserWebSocket(user.Member, token)
        }
    }
}

---

## Results & Performance
### We conducted a load test using K6 with 5,000 virtual users trying to buy 100 tickets simultaneously.

- Overselling: 0 (Zero). The database constraints held up perfectly.
- Latency: Average p95 response time was 120ms for the queue acknowledgment.
- Throughput: Successfully processed ~1,200 transactions per second on a modest t3.medium instance.

## Future Improvements
### While the system is robust, there's always room for growth:

- 1. **Geo-Replication**: Replicate the read-database to different regions for faster seat viewing.
- 2. **Dynamic Pricing**: Implement AI-based pricing depending on the demand velocity.
